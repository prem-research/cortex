"""gRPC server implementation for Cortex"""

import grpc
import asyncio
from concurrent import futures
import structlog
import sys
import os

# Add parent directory to path to import cortex
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from cortex.memory_system import AgenticMemorySystem
from app.config import get_settings
from app.cortex_service import CortexService

# Import generated protobuf modules (will be generated by compile_protos.py)
try:
    from app.generated import cortex_pb2, cortex_pb2_grpc
except ImportError:
    print("Please run 'python compile_protos.py' first to generate the protobuf modules")
    sys.exit(1)

logger = structlog.get_logger()
settings = get_settings()


class MemoryServiceServicer(cortex_pb2_grpc.MemoryServiceServicer):
    """gRPC service implementation"""
    
    def __init__(self):
        self.cortex_service = CortexService()
        logger.info("gRPC Memory Service initialized")
    
    def StoreMemory(self, request, context):
        """Store a new memory"""
        try:
            memory_id = self.cortex_service.store_memory(
                content=request.content,
                context=request.context if request.context else None,
                tags=list(request.tags) if request.tags else None,
                timestamp=request.timestamp if request.timestamp else None,
                user_id=request.user_id if request.user_id else None,
                session_id=request.session_id if request.session_id else None,
                metadata=dict(request.metadata) if request.metadata else None
            )
            
            return cortex_pb2.StoreMemoryResponse(
                id=memory_id,
                success=True,
                message="Memory stored successfully"
            )
        except Exception as e:
            logger.error("Error storing memory", error=str(e))
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return cortex_pb2.StoreMemoryResponse(
                id="",
                success=False,
                message=f"Error: {str(e)}"
            )
    
    def SearchMemories(self, request, context):
        """Search for memories"""
        try:
            results = self.cortex_service.search_memories(
                query=request.query,
                limit=request.limit if request.limit > 0 else 10,
                memory_source=request.memory_source if request.memory_source else "all",
                context=request.context if request.context else None,
                tags=list(request.tags) if request.tags else None,
                exclude_content=request.exclude_content,
                include_links=request.include_links,
                apply_postprocessing=request.apply_postprocessing,
                user_id=request.user_id if request.user_id else None,
                session_id=request.session_id if request.session_id else None,
                temporal_weight=request.temporal_weight if request.temporal_weight > 0 else None,
                date_range=request.date_range if request.date_range else None
            )
            
            # Convert results to protobuf format
            memories = []
            for memory in results["memories"]:
                mem = cortex_pb2.Memory(
                    id=memory.get("id", ""),
                    content=memory.get("content", ""),
                    context=memory.get("context", ""),
                    tags=memory.get("tags", []),
                    keywords=memory.get("keywords", []),
                    timestamp=str(memory.get("timestamp", "")),
                    score=float(memory.get("score", 0.0)) if memory.get("score") else 0.0,
                    is_linked=memory.get("is_linked", False),
                    memory_tier=memory.get("memory_tier", ""),
                    collection_name=memory.get("collection_name", ""),
                    category=memory.get("category", ""),
                    composite_score=float(memory.get("composite_score", 0.0)) if memory.get("composite_score") else 0.0
                )
                
                if memory.get("relationship_type"):
                    mem.relationship_type = memory["relationship_type"]
                if memory.get("relationship_strength"):
                    mem.relationship_strength = float(memory["relationship_strength"])
                if memory.get("relationship_reason"):
                    mem.relationship_reason = memory["relationship_reason"]
                
                memories.append(mem)
            
            return cortex_pb2.SearchMemoryResponse(
                memories=memories,
                count=len(memories),
                query_metadata={}
            )
        except Exception as e:
            logger.error("Error searching memories", error=str(e))
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return cortex_pb2.SearchMemoryResponse(memories=[], count=0)
    
    def DeleteMemory(self, request, context):
        """Delete a memory"""
        try:
            success = self.cortex_service.delete_memory(
                memory_id=request.memory_id,
                user_id=request.user_id if request.user_id else None,
                session_id=request.session_id if request.session_id else None
            )
            
            return cortex_pb2.DeleteMemoryResponse(
                success=success,
                message="Memory deleted successfully" if success else "Memory not found"
            )
        except Exception as e:
            logger.error("Error deleting memory", error=str(e))
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return cortex_pb2.DeleteMemoryResponse(
                success=False,
                message=f"Error: {str(e)}"
            )
    
    def UpdateMemory(self, request, context):
        """Update a memory"""
        try:
            success = self.cortex_service.update_memory(
                memory_id=request.memory_id,
                content=request.content if request.content else None,
                context=request.context if request.context else None,
                tags=list(request.tags) if request.tags else None,
                metadata=dict(request.metadata) if request.metadata else None
            )
            
            return cortex_pb2.UpdateMemoryResponse(
                success=success,
                message="Memory updated successfully" if success else "Memory not found"
            )
        except Exception as e:
            logger.error("Error updating memory", error=str(e))
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return cortex_pb2.UpdateMemoryResponse(
                success=False,
                message=f"Error: {str(e)}"
            )
    
    def ClearMemories(self, request, context):
        """Clear memories"""
        try:
            self.cortex_service.clear_memories(
                memory_source=request.memory_source,
                user_id=request.user_id if request.user_id else None,
                session_id=request.session_id if request.session_id else None
            )
            
            return cortex_pb2.ClearMemoryResponse(
                success=True,
                message=f"Memories cleared successfully from {request.memory_source}"
            )
        except Exception as e:
            logger.error("Error clearing memories", error=str(e))
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return cortex_pb2.ClearMemoryResponse(
                success=False,
                message=f"Error: {str(e)}"
            )
    
    def GetMemory(self, request, context):
        """Get a memory by ID"""
        try:
            memory = self.cortex_service.get_memory(
                memory_id=request.memory_id,
                user_id=request.user_id if request.user_id else None,
                session_id=request.session_id if request.session_id else None
            )
            
            if memory:
                mem = cortex_pb2.Memory(
                    id=memory.get("id", ""),
                    content=memory.get("content", ""),
                    context=memory.get("context", ""),
                    tags=memory.get("tags", []),
                    keywords=memory.get("keywords", []),
                    timestamp=str(memory.get("timestamp", "")),
                    memory_tier=memory.get("memory_tier", ""),
                    category=memory.get("category", "")
                )
                
                return cortex_pb2.GetMemoryResponse(
                    memory=mem,
                    found=True
                )
            else:
                return cortex_pb2.GetMemoryResponse(
                    found=False
                )
        except Exception as e:
            logger.error("Error getting memory", error=str(e))
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return cortex_pb2.GetMemoryResponse(found=False)


def serve():
    """Start the gRPC server"""
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=settings.grpc_max_workers))
    cortex_pb2_grpc.add_MemoryServiceServicer_to_server(MemoryServiceServicer(), server)
    
    # Enable reflection for debugging
    from grpc_reflection.v1alpha import reflection
    SERVICE_NAMES = (
        cortex_pb2.DESCRIPTOR.services_by_name['MemoryService'].full_name,
        reflection.SERVICE_NAME,
    )
    reflection.enable_server_reflection(SERVICE_NAMES, server)
    
    server_address = f'[::]:{settings.grpc_server_port}'
    server.add_insecure_port(server_address)
    server.start()
    
    logger.info(f"gRPC server started on {server_address}")
    
    try:
        server.wait_for_termination()
    except KeyboardInterrupt:
        logger.info("Shutting down gRPC server...")
        server.stop(0)


if __name__ == '__main__':
    serve()